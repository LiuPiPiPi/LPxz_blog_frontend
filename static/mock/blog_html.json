[
  {
    "blogTitle": "计算机网络学习",
    "blogContent": "# 神州信息实习：月总结（2020年7月）\n\n\u200B\t尊敬的海经理你好，我是2020年暑期实习生刘碧豪，就读于西北工业大学，于7月13日开始在本公司进行本科生短期实习，目前暂定实习时间为4个月，实习岗位为 Java 后端开发。以下是我对于本年度7月份的总结以及对之后实习过程的目标、展望和反馈。\n\n### 回顾\n\n\u200B\t自开始实习以来，我已经在公司实习了三周，已经基本熟悉了公司的环境和人员配置。在来公司的第一天被分配到了**场景金融**部门，并由**乌宏飞**作为我的实习导师，在后端开发上给我做相应的指导。乌宏飞导师在开始阶段便帮助我搭建好了项目运行所需要的环境，使我能够迅速地**接触到项目实现代码**，我们开发人员一贯认同“show me the code”思想，所以我认为这使我很快就能**了解到自己在技术上的欠缺之处**，之后的一段时间，我与导师在中午吃饭的时间里积极探讨开发中有疑惑的问题，并在茶余饭后的闲谈中了解了公司的部门配置和管理层级的分配，这对我作为一个学生首次对于职场有了亲身体会。\n\n\u200B\t最初接触到的项目是一个复杂的整合项目，应用了 OSGI 与 微服务框架。工作之间里，我利用网络上的学习资料，对于**微服务**概念展开了一系列的了解，并利用电子书籍学习 **Spring Cloud** 框架，特别的是，我正是在这段学习过程中了解了当时面试时被问到过的**负载均衡**的概念和实现原理，在这段学习过程中，我更是不断被新的名词所冲击，**熔断、Swagger、REST、Redis、MongoDB** 等等，近些年出现的新技术我都只是有所耳闻，如今才是真正的去了解和使用。\n\n\u200B\t一周之后，我们项目组接到了**秦皇岛分行**的需求，于是乌宏飞导师这一次重新搭建了代码结构，纯使用微服务框架，并指导我通过前端界面调用寻找功能实现的代码，接触着真正的代码量庞大的项目，我才能感受到好的开发框架和开发工具的效率。在接下来的一周里，我**继续学习着微服务和项目代码设计到的技术**。研究了企业开发的代码，我也了解到学生时期写出来的代码确实是漏洞百出，禁不起全面的测试。\n\n\u200B\t在第三周时，我的**导师出差**去秦皇岛，项目负责人让我**学习前端**知识，所以我便展开了对 **React** 的入门学习，由于之前对前端也有兴趣，所以接触过 HTML, CSS, JS 等前端基础，在临近实习时，我通过网络视频等方式自学并简单**入门了 Vue 前端框架**，理解了前端开发的**组件化思想**，所以在学习 React 的过程中不算特别吃力，但是 React 零碎的技术体系还是使我在一周后仍未感觉真正掌握了 React。\n\n### 目标\n\n\u200B\t在对新技术的学习过程中我还在继续进行着我的个人博客搭建工作，作为我的第一个目标，我计划在8月份内完成**对个人博客的前后端开发**，并且**部署上线**。我计划首次采用 Lombok 插件、Mybatis 持久层框架、Vue 前端框架、Nginx等进行实现。博客功能上线后能更方便地与其他实习生交流心得，也能更好地记录自己的学习。\n\n\u200B\t其次我计划在8月更深度地学习 **Spring Cloud 及微服务框架涉及的众多技术**，微服务作为新兴技术，进行深度的学习能够洞察技术发展方向，汲取前沿人才的优秀思想。并且在学习过程中，一定会发现更多的分支，建立完善的技能体系。\n\n\u200B\t虽然实习岗位是后端开发，但是我依然有兴趣自学前端框架，掌握必要的思想和技术，**需要用什么，就尽量学懂什么**。我也希望与几位前端开发的实习生能多做交流，互通有无，争取向着全栈工程师努力。\n\n\u200B\t针对项目开发，我仍然认同**接触代码、实战才是最快的学习方式**，我将侧重于功能实现、工具类实现、测试验证、异常处理、文档输出、接口管理、数据库管理和调用等方面对已有代码进行细致的学习。\n\n\u200B\t在后面的日子其实还有一个小目标，就是努力**和身边的实习生及入职人员熟悉**起来，毕竟已入职人员身上有着多年沉淀下来的经验，属实可遇不可求，我会积极向前辈学习。同为实习生的我们，更多的交流能带来信息的交换，也能更清楚自己的定位，清楚自己需要做什么，一起进步也是一种前进的动力。\n\n### 反馈\n\n\u200B\t这三周的实习生活总体上很顺利，也很充实。针对我们提出的问题，海经理及公司都尽量为我们解决。\n\n\u200B\t不过因为导师出差的原因，我现在暂时被分配学习前端。我的个人意向还是更希望自己在公司里**作为后端开发实习**，前端的基础相对薄弱，我需要更多的时间补充基础知识，而后端的知识水平虽说还远远不足以入职，但也能在项目中做出实际的贡献。另外的原因，是我确实想回到**一号楼**这边来实习，和我一批的实习生全部在这里，我和他们交流学习起来也更加方便。\n\n\u200B\t还有一点个人疑问是我们的**补助发放是否要扣除个人所得税**，我对这一点尚不清楚，希望能有所了解。\n\n\u200B\t除此之外再没什么需要麻烦的事情，承蒙海经理和公司的照顾，也得益于校企合作的关系，给了我这份实习机会，我会好好珍惜，并不断努力，争取为公司带来实际的工作成果。\n\n---\n\n<div align=\"right\">刘碧豪</div>\n\n<div align=\"right\">2020 年 8 月 1 日</div>",
    "blogTags": [
      "Java",
      "Python",
      "Vue"
    ]
  },
  {
    "blogTitle": "计算机网络学习",
    "blogContent": "### 限制 clone 深度，加快下载速度\n\n **仅是 clone 此仓库学习（不是参与翻译工作）的话，请使用如下 Git 命令**：\n\n```shell\ngit clone --depth 1 https://github.com/labuladong/fucking-algorithm.git\n```\n\n这样会限制 clone 的深度，不会下载 Git 协作的历史记录，可以极大加快下载速度。\n\n### 解决：'touch' 不是内部或外部命令，也不是可运行的程序或批处理文件\n\n在 Windows 的 cmd 中我们可以使用 echo test>\n\n<img src=\".\\md_pic\\image-20200809183113702.png\" alt=\"image-20200809183113702\" style=\"zoom:80%;\" align=\"left\"/>\n\n\n\n---\n\n> 以下知识点来源：神州信息岗前培训资料\n\n## 1.创建版本库\n\n- 版本库又名仓库，英文名称是repository\n- 如何创建一个版本库，\n\t```java\n\tmkdir GitRepository\n\tcd GitRepository\n\tgit init\n\t```\n\t\n\t这样一个新的版本库就建立好了\n## 2.  添加文件到版本当前版本库\n\n- 下面是操作命令\n\n  ```java\n  vim readme,txt 内容随意\n  git add readme.txt  添加文件到仓库\n  git commit -m '本次提交的说明,具有意义的说明'  将文件提交到仓库\n  ```\n\n  ```java\n  git commit -m 'wrote a readme file again'\n  [master f4294a4] wrote a readme file again\n  1 file changed, 1 insertion(+), 1 deletion(-)\n  ```\n\n- 上面的提示告诉我们，1个文件被改动(添加了1个新的文件)，插入了1行内容() 1行缺失\n\t\t疑问：为啥有了git add, 还需要git commit -m ' ' \n因为git commit一次可以提交很多文件，所以你可以多次add不同的文件,比如:\n\t\t\n\t\t```\n\t\tgit add file1.txt\n\t\tgit add file2.txt file3.txt\n\t\tgit commit -m 'add 3 files'\n\t\t```\n\n## 3.修改文件\n\n- 下面是操作命令\n\n  ```java\n  vim readme.txt 随意修改\n  git status 查看当前版本库的状态\n  ```\n\n  显示结果为\n\n  ```java\n  位于分支 master\n  尚未暂存以备提交的变更：\n  \t（使用 \"git add <文件>...\" 更新要提交的内容）\n  \t（使用 \"git checkout -- <文件>...\" 丢弃工作区的改动）\n  \t\t修改：     readme.txt\n  修改尚未加入提交（使用 \"git add\" 和/或 \"git commit -a\"）\n  ```\n\n- 上面的提示告诉我们readme.txt文件已经被我们修改了,但是还没有准备提交\n\n  ```java\n  git diff readme.txt  查看readme.txt文件哪里被修改\n  diff --git a/readme.txt b/readme.txt\n  \tindex f362e74..be74d7a 100644\n  \t--- a/readme.txt\n  \t+++ b/readme.txt\n  \t@@ -1,2 +1,2 @@\n  \t-Git is a version control system\n  \t+Git is a distributted version control system\n  \tGit is a free software\n  ```\n\n- 上面的提示告诉我们，我们增加了一个\"distributted\"单词\n  知道了是什么修改之后我们可以提交修改后的文档\n\n  ```java\n  git add readme.txt\n  git status 查看状态\n  位于分支 master\n  \t要提交的变更：\n   \t（使用 \"git reset HEAD <文件>...\" 以取消暂存）\n  \t\t修改：     readme.txt\n  上面的提示告诉我们，将要被提交的修改包括readme.txt\n  git commit -m 'add distributted'\n  git status 查看状态\n  ```\n\n## 4.版本回退\n- 一个文件需要不停的修改，commit被理解为是保存一个快照，依靠快照可以进行文件版本的回退和前进\n\n- -readme.txt文件有两个commit\n  git log  查看最近到最远的提交日志\n\n  ```java\n  commit e8574e2fb9c41064114a3c4cd95e59f89e5d6aa8 (HEAD -> master)\n  Author: suhang <1552899301@qq.com>\n  Date:   Sat Apr 20 17:23:04 2019 +0800\n  \n  add distributted\n  \n  commit f4294a40f471bd8643020e8b9d244af02182b241\n  Author: suhang <1552899301@qq.com>\n  Date:   Sat Apr 20 16:45:30 2019 +0800\n  \n  wrote a readme file again\n  \n  commit 99222c5143e88259af1ee1acf3f482c1a50b2d68\n  Author: suhang <1552899301@qq.com>\n  Date:   Sat Apr 20 16:07:31 2019 +0800\n  \n  wrote a readme file\n  ```\n\n- 日志按照修改时间从上往下为近到远\n   用HEAD表示当前版本 上一个版本就是HEAD^, 上上一个版本就是HEAD^^， 向上100个版本就是HEAD^~100\n\n   ```java\n   git reset --hard HEAD^  返回上一个版本\n   ```\n\n- 既然返回上一个版本，怎样返回去呢，使用版本号可以回去(使用git reflog)查看使用命令，此时查看每一个版本的版本号\n\n  ```java\n  git reset --hard e8574  e8574为commit 的前几位- \n  ```\n\n## 5.工作区(Working Directory)\n- gitspeace就是一个工作区\n## 6.版本库(Repository)\n- 工作区有一个隐藏的目录.git 这个不算工作区，算是Git的版本库\n- Git的版本库中存放着许多的文件，最为重要的是stage或者叫index的暂存区，还有Git为我们创建的一个分支master。\n- 可以简单的理解为:使用git add可以把需要提交的文件修改通通添加到stage(index)暂存区, 然后再使用git commit -m '提示' 将暂存区的文件一次性提交到master分支\n## 7.管理修改\n- Git具有跟踪修改的特点: 第一次修改 git add 第二次修改 git commit\n- 上面的流程第二次修改是不会成功的，因为每一次修改之后，不使用git add到暂存区，就不会加入到commit中\n- 上面的流程可以更改为: 第一次修改 git add 第二次修改 git add 最后git commit\n## 8.撤销修改\n- (1).更改文件之后，但是没有使用git add将修改文件添加到暂存区，可以使用一下命令\n\n  ```java\n  git checkout -- filename 丢弃工作区的改动\n  ```\n\n- (2).如果将文件修改之后，而且使用了git add将文件添加到暂存区，但是没有使用git commit添加到分支，此时使用git reset HEAD <file> 取消暂存此时修改之后而且被添加到暂存区的文件，将会回退到到工作区，注意的是被修改的状态仍未被回退，使用git checkout -- filename 放弃工作区的修改\n\n## 9.删除文件\n- 当你删除了工作区的文件之后，使用git status查看当前版本库的状态\n- 使用git checkout -- filename撤销删除 (将版本库中的文件替换到工作区)或者使用git rm 删除版本库的文件\n- 使用git commit 'remove file' 添加快照\n## 10.配置github 远程仓库\n\n- 下面是操作命令\n\n  ```java\n  ssh-keygen -t rsa -C \"1552899301@qq.com\"\n  回车 默认秘钥生成位置为.ssh/ 输入秘钥密码(可选),此密码在git remote add origin git@github.com:username/yourRepository.git(关联远程仓库)时候使用\n  然后git push -u origin master 推送内容到远程库上\n  因为远程库是空的，我们第一次推送master分支时候，加上-u参数,不但会\n  把本地的master分支内容推送到远程的新仓库，还把本地的master和本地的master关联起来\n  ```\n\n## 11.从远程仓库克隆\n- 首先，在github官网上创建仓库，然后克隆到本地 记得勾选Initialize this repository a README\n- 使用git clone git@github.com:yourname/yourRepository.git\n## 12.分支管理\n- 分支的作用是，当你准备开发一个新的功能的时候，但是需要两周才能完成，第一周你写了50%的代码，如果不能立刻提交，由于代码还没完成，不完整的代码库会导致别人无法工作，如果等代码全部再一次提交，又存在丢失进度的风险,现在有了分支,就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的的分支上正常工作，而你在你的分支上干活，想提交提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不会影响别人工作。\n## 13.创建分支\n- 在版本会退中，你已经知道，每一次提交，Git都把他们串成一条时间线，这条时间线就是一个分支，Git中的master分支称为主分支，HEAD严格来说并不是指向提交，而是指向master,master才指向提交，所以HEAD指向的是当前分支\n\n- 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点:\n\n- 每次提交，master分支都会向前移动一步，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点\n\n- 每一次提交，master分支都会向前移动一步，这样随着不断的提交，master分支的线会越来越长当我们创建新的分支的时候，例如dev，Git新建了一个指针dev，指向master相同的提交，再把HEAD指向dev，就表示在当前分支在dev上现在会与工作区的修改和提交就是针对dev分支了，比如，提交一次之后，dev向前移动一步，而master指针不变，假如我们在dev上的工作完成了，就可以把dev合并到master上\n\n- 下面是一个简单的操作:\n\n  ```java\n  创建一个dev分支，然后切换到dev分支:\n      \tgit checkout -b dev\n  然后查看当前分支\n      \tgit branch  会在当前分支前面标记一个*\n  此时修改readme.txt 增加随意的一句话\n  dev的分支的工作完成之后，我们就可以切换回master分支:\n      \tgit checkout master\n  此时查看readme.txt 发现文件并没有改变，原因在于改变文件的操作是在dev分支上完成的,跟master没有任何关系,这时候我们需要完成合并分支的操作\n      \tgit merge dev  将当前分支合并(master)到dev上\n  删除dev分支\n      \tgit branch -b dev\n  ```\n## 14.解决冲突\n- 在合并分支的时候，会出现冲突问题\n\n  ```java\n  下面是一个简单的例子:\n  创建分支fea 并且换为当前分支\n      \tgit checkout -b fea\n  修改readme.txt 增加一句话 001\n  提交分支:\n      \tgit add readme.txt\n      \tgit commit -m \"001\"\n  切换到主分支\n      \tgit checkout master\n  修改readme.txt 增加一句话 002\n  提交分支:\n      \tgit add readme.txt\n      \tgit commit -m \"002\"\n  合并分支 \n      \tgit merge fea\n  提示报错,因为，两个分支分别对文件进行了不同的修改，自然无法合并。此时需要解决冲突，就是修改刚才合并失败的文件\n      \tvim readme.txt\n  分之1:001\n  分支2:002\n  随便删除一个就好\n  提交分支:\n      \tgit add readme.txt\n      \tgit commit -m \"fixed\"\n  ```\n## 15.分支管理策略\n- 1.通常合并分支，如果可能，git会采用fast forward模式，但是这种模式下，删除分支之后，会丢失一些分支信息,如果轻质禁用fast forward模式，git就会在merge时，生成一个新的commit,我们从分支历史上就可以看到分支信息\n\n  ```java\n  下面我们使用--on--ff的方式git merge\n  首先，创建并且切换到dev分支\n      \tgit checkout -b dev\n  修改readme.txt文件\n      \tgit add readme.txt\n      \tgit commit \"add merge\"\n  切换到master分支\n      \tgit checkout master\n  准备合并dev分支，使用--no--ff（禁用fast forward）\n      \tgit merge--no-ff -m \"merge with no-ff\" dev  本次合并要创建一个新的commit,所以加上-m参数，把commit描述写进去\n  使用git log看看分支历史\n      \tgit log -- grep -pretty=oneline --abbrev-commit\n  ```\n- 2.分支管理策略\n\t- 首先，master分支应该是最稳定的，也就是仅用来发布新版本的，平时不能用来干活;\n\t- 平时工作均在dev分支上，也就是说，dev是不稳定的，比如说要发布1.0版本的时候。再把dev分支合并到master上，在master分支上发布1.0版本，你和你的小伙伴都在dev上干活，每个人都有子的分支，时不时的往master上合并\n## 16.Bug分支\n- 在软件开发中，bug就像家常便饭一样，有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每一个bug都可以通过一个新的临时分支修复，合并分支，然后将临时分支删除\n\n- 当你接受到一个修复1号代码，创建一个分支01来修复它，但是，等等当前正在dev上进行的工作还没有提交:\n\t\n\t- Git提供了一个stash功能，可以把当前工作现场\"储藏\"起来，等以后在恢复使用\n\t\n- 首先确定bug是位于哪一个分支上的，加入在主分支上，就从主分支master创建临时分支\n\n  ```java\n  git checkout -b 01\n  现在修复bug，编辑readme.txt\n  修复完成后，提交\n      git add readme.txt\n      git commit -m \"bug fixed\" \n  切换分支\n      git checkout master\n  合并分支\n      git merge --no-ff -m \"merge bug fix 01\" 01\n  切换回刚才工作的分支\n      git checkout dev\n      git status 查看状态\n  显示工作区是干净的\n      git stash list 查储藏工作区列表\n  第一种是：git stash apply恢复 但是stash没有删除，需要使用\n      git stash drop 删除 \n  第二种是：git stash pop 恢复的同时把stash也删除了\n  可以多次stash 恢复的时候，先用git stash list查看，最后恢复指定的stash git stash apply stash@{0}\n  ```\n## 17.新功能分支\n- 当你要开发一个新功能的时候，需要创建一个分支，等到新功能开发好，再合并分支，然后删除新的分支\n- 使用git branch -D 分支名称  -D 强制删除\n##  18.多人协作\n- 当你从远程仓库克隆时候，实际上把Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称是origin 使用git remote 或者使用 git remote -v显示更详细的信息;\n\n- 例如:\n\n  ```java\n  git remote -v \n  origingit @github.com:suhang12332/gitspeace.git(fetch)\n  origin git@github.com:suhang12332/gitspeace.git(push)\n  ```\n\n上面显示了可以抓取和推送的origin的地址，如果没有推送权限，就看不到push的地址\n- 推送分支:就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上；\n\n  ```java\n  git push origin master\n  如果需要推送其他分支,比如dev\n  git push origin dev\n  ```\n\n- 抓取分支\n  - 多人协作时，大家都会往master和dev分支上推送各自修改。现在，模拟一个你的小伙伴，可以在另一台电脑(注意要把SSH添加到github)或者同一台电脑的另一个目录下克隆\n\n    ```java\n    git clone git@github.com:suhang12332/gitspeace.git\n    ```\n\n  - 当你的小伙伴从远程clone时，默认情况下，你的小伙伴只能看到本地的master分支 使用git branch 现在，你的小伙伴要在dev上开发分支，就必须创建origin到dev分支到本地dev\n\n    ```java\n    git checkout -b dev origin/dev\n    创建完成后，就可以在dev分支上继续修改，然后时不时的将dev分支推送到远程分支上\n           git add ***.txt\n           git commit -m \"add ***\"\n           此时你也向origin/dev分支提交，并试图推送，\n           git add ***.txt\n           git commit -m \"add new ***\"\n           git push origin dev\n    ```\n\n  - 推送失败，因为你的小伙伴的最新提交和你试图提交有冲突，解决办法很简单，git已经提示我们，先用git pull把最新的origin/dev抓下来，然后合并，解决冲突，再推送 \n\n  - git pull 这样使用是失败的因为你没有指定本地dev与远程origindev分支的链接，根据提示,设置dev和origin/dev的链接\n\n    ```java\n    git branch --set-upstream-to=origin/dev/dev\n    git pull\n    ```\n\n  - 可以总结:多人协作的模式如下：\n    - 1.首先，可以试图git push origin <origin-name>推送自己的修改\n    - 2.如果推送失败，因为远程分支比你本地更新，首先使用git pull合并\n    - 3.合并之前要指定本地的分支与远程的分支链接 git branch --set-upstream-to=origin/dev/dev\n      \n           \t- 4.合并没有冲突，即本地提交，有冲突，解决冲突\n                    \t- 5.没有冲突使用 \n       ```java\n        git push origin <branch name>\n       ```\n\n## 19.整理分支合并\n- 使用git rebase整理 使用、查看\n\n## 20.标签管理\n- 创建标签:首先切换到需要打标签的分支上\n\n  ```java\n  git checkout master \n  ```\n\n- 然后\n\n  ```java\n  git tag v1.0\n  使用 -a指定标签名字 使用-m指定说明文字\n  git tag -a v0.9 -m\"version0.9\" commit号码使用git tag查看所有标签\n  还可以使用git tag v1.0 commit号码,标签的顺序是按照字母的顺序排列的\n  使用show tagname查看标签属性\t\n  ```\n\n- 操作标签: 打错名字可以删除:\n\n  ```java\n  git tag -d tagname\n  ```\n\n- 推送标签到远程\n\n  ```java\n  git push origin tagname\n  ```\n\n- 说着一次性推送完所有的标签\n\n  ```java\n  git push origin -tags\n  ```\n\n- 删除远程标签;先删除本地，再删除远程\n\n  ```java\n  git push origin :refs/tags/v0.9\n  ```\n\n  \n\n",
    "blogTags": [
      "Java",
      "Python",
      "Vue"
    ]
  }
]
